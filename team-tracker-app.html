<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Progress Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .date-display {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(255, 255, 255, 1);
            color: #333;
            padding: 10px 18px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Dark theme styles */
        body.dark-theme {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        body.dark-theme .container {
            background: rgba(30, 30, 50, 0.95);
        }

        body.dark-theme .header {
            background: linear-gradient(135deg, #2d3561 0%, #1e2a5e 100%);
        }

        body.dark-theme .member-card {
            background: #2a2a3e;
            border-color: #444;
        }

        body.dark-theme .member-card:hover {
            border-color: #667eea;
        }

        body.dark-theme .member-name {
            color: #e0e0e0;
        }

        body.dark-theme .form-group label {
            color: #ccc;
        }

        body.dark-theme .form-group input, 
        body.dark-theme .form-group textarea, 
        body.dark-theme .form-group select {
            background: #3a3a4e;
            border-color: #555;
            color: #e0e0e0;
        }

        body.dark-theme .form-group input:focus, 
        body.dark-theme .form-group textarea:focus, 
        body.dark-theme .form-group select:focus {
            border-color: #667eea;
        }

        body.dark-theme .summary-section {
            background: linear-gradient(135deg, #2a2a3e 0%, #3a3a4e 100%);
        }

        body.dark-theme .summary-content {
            background: #2a2a3e;
            border-color: #555;
            color: #e0e0e0;
        }

        body.dark-theme .stat-card {
            background: #2a2a3e;
            color: #e0e0e0;
        }

        body.dark-theme .modal-content {
            background: #2a2a3e;
            color: #e0e0e0;
        }

        body.dark-theme .storage-info {
            background: #2a4a2a;
            border-color: #4caf50;
        }

        body.dark-theme .storage-info h4 {
            color: #4caf50;
        }

        body.dark-theme .storage-info p {
            color: #8bc34a;
        }

        body.dark-theme .task-item {
            background: #3a3a4e !important;
            border-color: #555 !important;
        }

        .main-content {
            padding: 30px;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn.success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .btn.warning {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }

        .btn.info {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        }

        .btn.purple {
            background: linear-gradient(135deg, #9c27b0 0%, #673ab7 100%);
        }

        .btn.small {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .team-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .member-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .member-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .member-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .member-name {
            font-size: 1.4rem;
            font-weight: 700;
            color: #333;
        }

        .status-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .status-blocked {
            background: #ffebee;
            color: #c62828;
        }

        .status-partially-blocked {
            background: #fff3e0;
            color: #ef6c00;
        }

        .status-reviewing {
            background: #e3f2fd;
            color: #1565c0;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .summary-section {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .summary-content {
            background: white;
            border-radius: 10px;
            padding: 20px;
            white-space: pre-wrap;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .date-picker {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .storage-info {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .storage-info h4 {
            color: #2e7d32;
            margin-bottom: 10px;
        }

        .storage-info p {
            color: #1b5e20;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .control-panel {
                flex-direction: column;
            }

            .team-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2rem;
            }

            .summary-header {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="theme-toggle" onclick="toggleTheme()" id="themeToggle">🌙 Dark</button>
            <h1>🚀 Team Progress Tracker</h1>
            <div class="date-display" id="currentDate"></div>
        </div>

        <div class="main-content">
            <div class="storage-info">
                <h4>📁 File Storage Instructions</h4>
                <p>This app saves daily progress in both JSON and CSV formats. JSON preserves all data for re-loading, while CSV is perfect for spreadsheet analysis. Use "Load Data" to import either format. For best organization, create a "team-data" folder to store all your files.</p>
            </div>

            <div class="control-panel">
                <button class="btn" onclick="addMember()">➕ Add Member</button>
                
                <!-- Save/Export Section -->
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <button class="btn success" onclick="saveTodayData()">💾 JSON</button>
                    <button class="btn success" onclick="saveTodayDataCSV()">📊 CSV</button>
                </div>
                
                <!-- Load/Import Section -->
                <div class="file-input-wrapper">
                    <input type="file" id="loadDataFile" class="file-input" accept=".json,.csv" onchange="loadData()">
                    <button class="btn info" onclick="document.getElementById('loadDataFile').click()">📂 Load Data</button>
                </div>
                
                <button class="btn warning" onclick="generateDailySummary()">📊 Daily Summary</button>
                <button class="btn purple" onclick="showWeeklySummary()">📈 Weekly Summary</button>
                <button class="btn" style="background: linear-gradient(135deg, #e91e63 0%, #ad1457 100%);" onclick="showTaskStateAnalysis()">🎯 Current Task State</button>
                <button class="btn small" onclick="clearToday()">🗑️ Clear Today</button>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalMembers">0</div>
                    <div class="stat-label">Team Members</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="activeCount">0</div>
                    <div class="stat-label">Active</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="blockedCount">0</div>
                    <div class="stat-label">Blocked</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="partiallyBlockedCount">0</div>
                    <div class="stat-label">Partially Blocked</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="reviewingCount">0</div>
                    <div class="stat-label">Reviewing</div>
                </div>
            </div>

            <div class="team-grid" id="teamGrid"></div>

            <div class="summary-section">
                <div class="summary-header">
                    <h3>📝 AI-Ready Summary</h3>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn small" onclick="copySummary()">📋 Copy</button>
                        <button class="btn small" onclick="exportSummary()">💾 Export</button>
                    </div>
                </div>
                <div class="summary-content" id="summaryContent">
                    Click "Daily Summary" to create an AI-ready report of today's progress...
                </div>
            </div>
        </div>
    </div>

    <!-- Add Member Modal -->
    <div id="memberModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeMemberModal()">&times;</span>
            <h2>Add Team Member</h2>
            <div class="form-group">
                <label for="memberName">Name:</label>
                <input type="text" id="memberName" placeholder="Enter member name">
            </div>
            <div class="form-group">
                <label for="memberRole">Role:</label>
                <input type="text" id="memberRole" placeholder="e.g., Frontend Developer">
            </div>
            <button class="btn success" onclick="saveMember()">Save Member</button>
        </div>
    </div>

    <!-- Weekly Summary Modal -->
    <div id="weeklySummaryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeWeeklySummaryModal()">&times;</span>
            <h2>📈 Weekly Summary Generator</h2>
            <div class="date-picker">
                <label>Week Starting:</label>
                <input type="date" id="weekStartDate">
                <button class="btn info small" onclick="generateWeeklySummary()">Generate</button>
            </div>
            <div id="weeklyFiles" style="margin-bottom: 20px;"></div>
            <div class="form-group">
                <label>Load Weekly Data Files (select multiple daily JSON or CSV files):</label>
                <input type="file" id="weeklyDataFiles" multiple accept=".json,.csv" onchange="loadWeeklyFiles()">
            </div>
            <div class="summary-content" id="weeklySummaryContent" style="max-height: 300px;">
                Select week start date and load daily data files to generate weekly summary...
            </div>
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn small" onclick="copyWeeklySummary()">📋 Copy Summary</button>
                <button class="btn small" onclick="exportWeeklySummary()">💾 Export TXT</button>
                <button class="btn small" onclick="exportWeeklySummaryCSV()">📊 Export CSV</button>
                <button class="btn small" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);" onclick="compressWeeklySummaryContent()">🗜️ Compress AI Summary</button>
            </div>
        </div>
    </div>

    <!-- Task State Analysis Modal -->
    <div id="taskStateModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closeTaskStateModal()">&times;</span>
            <h2>🎯 Current Task State Analysis</h2>
            <div class="form-group">
                <label>Load Historical Data Files (select multiple daily JSON or CSV files):</label>
                <input type="file" id="taskStateDataFiles" multiple accept=".json,.csv" onchange="loadTaskStateFiles()">
            </div>
            <div id="taskStateFiles" style="margin-bottom: 20px;"></div>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn info small" onclick="generateTaskStateAnalysis()">🔍 Analyze Tasks</button>
                <button class="btn small" onclick="generateCurrentTaskSummary()">📊 Current State Summary</button>
                <button class="btn small" style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);" onclick="generateTechnicalTaskAnalysis()">🔧 Technical Task Analysis</button>
            </div>
            <div class="summary-content" id="taskStateContent" style="max-height: 400px;">
                Load historical data files and click "Analyze Tasks" to generate comprehensive task state analysis for GenAI...
            </div>
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn small" onclick="copyTaskStateAnalysis()">📋 Copy Analysis</button>
                <button class="btn small" onclick="exportTaskStateAnalysis()">💾 Export Analysis</button>
                <button class="btn small" onclick="exportTaskStateCSV()">📊 Export CSV</button>
                <button class="btn small" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);" onclick="compressTaskStateContent()">🗜️ Compress AI Summary</button>
            </div>
        </div>
    </div>

    <!-- Include configuration files -->
    <script src="user-profile.js"></script>
    <script src="sample-data.js"></script>
    
    <script>
        let teamData = [];
        let memberIdCounter = 1;
        let currentDate = new Date().toISOString().split('T')[0];
        let weeklyData = [];

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            updateCurrentDate();
            setDefaultWeekStart();
            loadThemePreference();
            renderTeam();
        });

        function updateCurrentDate() {
            const now = new Date();
            const options = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            };
            document.getElementById('currentDate').textContent = now.toLocaleDateString('en-US', options);
            currentDate = now.toISOString().split('T')[0];
        }

        function toggleTheme() {
            const body = document.body;
            const themeToggle = document.getElementById('themeToggle');
            
            if (body.classList.contains('dark-theme')) {
                body.classList.remove('dark-theme');
                themeToggle.textContent = '🌙 Dark';
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.add('dark-theme');
                themeToggle.textContent = '☀️ Light';
                localStorage.setItem('theme', 'dark');
            }
        }

        function loadThemePreference() {
            const savedTheme = localStorage.getItem('theme');
            const themeToggle = document.getElementById('themeToggle');
            
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
                themeToggle.textContent = '☀️ Light';
            } else {
                document.body.classList.remove('dark-theme');
                themeToggle.textContent = '🌙 Dark';
            }
        }

        function setDefaultWeekStart() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            const monday = new Date(today);
            monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
            document.getElementById('weekStartDate').value = monday.toISOString().split('T')[0];
        }

        function addMember() {
            document.getElementById('memberModal').style.display = 'block';
        }

        function closeMemberModal() {
            document.getElementById('memberModal').style.display = 'none';
            document.getElementById('memberName').value = '';
            document.getElementById('memberRole').value = '';
        }

        function saveMember() {
            const name = document.getElementById('memberName').value.trim();
            const role = document.getElementById('memberRole').value.trim();

            if (!name) {
                alert('Please enter a member name');
                return;
            }

            const newMember = {
                id: memberIdCounter++,
                name: name,
                role: role || 'Team Member',
                status: 'active',
                yesterday: '',
                today: '',
                blockers: '',
                notes: '',
                tasks: [], // Initialize with empty tasks array
                lastUpdated: new Date().toISOString()
            };

            teamData.push(newMember);
            renderTeam();
            closeMemberModal();
        }

        function updateMember(id, field, value) {
            const member = teamData.find(m => m.id === id);
            if (member) {
                member[field] = value;
                member.lastUpdated = new Date().toISOString();
                updateStats();
            }
        }

        function removeMember(id) {
            if (confirm('Are you sure you want to remove this team member?')) {
                teamData = teamData.filter(m => m.id !== id);
                renderTeam();
            }
        }

        function renderTeam() {
            const grid = document.getElementById('teamGrid');
            grid.innerHTML = '';

            teamData.forEach(member => {
                const memberCard = document.createElement('div');
                memberCard.className = 'member-card';
                memberCard.innerHTML = `
                    <div class="member-header">
                        <div>
                            <div class="member-name">${member.name}</div>
                            <div style="color: #666; font-size: 0.9rem;">${member.role}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span class="status-badge status-${member.status}">${member.status.replace('-', ' ')}</span>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.8rem;" onclick="removeMember(${member.id})">❌</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Status:</label>
                        <select onchange="updateMember(${member.id}, 'status', this.value)" value="${member.status}">
                            <option value="active" ${member.status === 'active' ? 'selected' : ''}>🟢 Active</option>
                            <option value="blocked" ${member.status === 'blocked' ? 'selected' : ''}>🔴 Blocked</option>
                            <option value="partially-blocked" ${member.status === 'partially-blocked' ? 'selected' : ''}>🟡 Partially Blocked</option>
                            <option value="reviewing" ${member.status === 'reviewing' ? 'selected' : ''}>🔵 In Review</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>✅ What I did yesterday:</label>
                        <textarea placeholder="Completed tasks from yesterday..."
                                  onchange="updateMember(${member.id}, 'yesterday', this.value)">${member.yesterday}</textarea>
                    </div>

                    <div class="form-group">
                        <label>🎯 What I'm doing today:</label>
                        <textarea placeholder="Today's planned tasks..."
                                  onchange="updateMember(${member.id}, 'today', this.value)">${member.today}</textarea>
                    </div>

                    <div class="form-group">
                        <label>🚧 Blockers/Issues:</label>
                        <textarea placeholder="Any blockers or issues..."
                                  onchange="updateMember(${member.id}, 'blockers', this.value)">${member.blockers}</textarea>
                    </div>

                    <div class="form-group">
                        <label>📝 Additional Notes:</label>
                        <textarea placeholder="Any additional notes or updates..."
                                  onchange="updateMember(${member.id}, 'notes', this.value)">${member.notes}</textarea>
                    </div>

                    <!-- Task Tracking Section -->
                    <div class="form-group">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="margin: 0;">📋 Current Tasks</label>
                            <button class="btn small" onclick="addTask(${member.id})" style="padding: 5px 10px;">➕ Add Task</button>
                        </div>
                        <div id="tasks-${member.id}">
                            ${renderTasks(member.id, member.tasks)}
                        </div>
                    </div>
                `;
                grid.appendChild(memberCard);
            });

            updateStats();
        }

        function renderTasks(memberId, tasks) {
            if (!tasks || tasks.length === 0) {
                return '<div style="color: #666; font-style: italic; padding: 10px;">No tasks added yet</div>';
            }

            let tasksHtml = '';
            tasks.forEach((task, index) => {
                tasksHtml += `
                    <div class="task-item" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background: #f9f9f9;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <input type="text" 
                                   placeholder="Task title" 
                                   value="${task.title || ''}"
                                   onchange="updateTask(${memberId}, ${index}, 'title', this.value)"
                                   style="flex-grow: 1; margin-right: 10px; font-weight: bold;">
                            <button class="btn" style="padding: 5px 10px; font-size: 0.8rem;" onclick="removeTask(${memberId}, ${index})">❌</button>
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Status:</label>
                            <select onchange="updateTask(${memberId}, ${index}, 'status', this.value)" value="${task.status || 'active'}">
                                <option value="active" ${task.status === 'active' ? 'selected' : ''}>🟢 Active</option>
                                <option value="partially-blocked" ${task.status === 'partially-blocked' ? 'selected' : ''}>🟡 Partially Blocked</option>
                                <option value="blocked" ${task.status === 'blocked' ? 'selected' : ''}>🔴 Blocked</option>
                                <option value="reviewing" ${task.status === 'reviewing' ? 'selected' : ''}>🔵 In Review</option>
                                <option value="completed" ${task.status === 'completed' ? 'selected' : ''}>✅ Completed</option>
                            </select>
                        </div>
                        
                        ${task.status !== 'active' && task.status !== 'completed' ? `
                        <div class="form-group">
                            <label>Issue/Blocker Details:</label>
                            <textarea placeholder="Describe the issue or blocker..."
                                      onchange="updateTask(${memberId}, ${index}, 'issue', this.value)"
                                      style="min-height: 60px;">${task.issue || ''}</textarea>
                        </div>
                        ` : ''}
                        
                        <div class="form-group">
                            <label>📋 Task Notes/Current Status:</label>
                            <textarea placeholder="Add notes about current progress, blockers, or next steps..."
                                      onchange="updateTask(${memberId}, ${index}, 'notes', this.value)"
                                      style="min-height: 60px;">${task.notes || ''}</textarea>
                        </div>
                        
                        <div class="form-group">
                            <label>🎯 Next Steps:</label>
                            <textarea placeholder="What needs to be done next for this task..."
                                      onchange="updateTask(${memberId}, ${index}, 'nextSteps', this.value)"
                                      style="min-height: 60px;">${task.nextSteps || ''}</textarea>
                        </div>
                    </div>
                `;
            });
            return tasksHtml;
        }

        function addTask(memberId) {
            const member = teamData.find(m => m.id === memberId);
            if (member) {
                if (!member.tasks) member.tasks = [];
                member.tasks.push({
                    title: '',
                    status: 'active',
                    issue: '',
                    notes: '',
                    nextSteps: ''
                });
                renderTeam();
            }
        }

        function removeTask(memberId, taskIndex) {
            const member = teamData.find(m => m.id === memberId);
            if (member && member.tasks) {
                member.tasks.splice(taskIndex, 1);
                renderTeam();
            }
        }

        function updateTask(memberId, taskIndex, field, value) {
            const member = teamData.find(m => m.id === memberId);
            if (member && member.tasks && member.tasks[taskIndex]) {
                member.tasks[taskIndex][field] = value;
                member.lastUpdated = new Date().toISOString();
                
                // Re-render to show/hide issue field based on status
                if (field === 'status') {
                    renderTeam();
                }
            }
        }

        function updateStats() {
            const total = teamData.length;
            const active = teamData.filter(m => m.status === 'active').length;
            const blocked = teamData.filter(m => m.status === 'blocked').length;
            const partiallyBlocked = teamData.filter(m => m.status === 'partially-blocked').length;
            const reviewing = teamData.filter(m => m.status === 'reviewing').length;

            document.getElementById('totalMembers').textContent = total;
            document.getElementById('activeCount').textContent = active;
            document.getElementById('blockedCount').textContent = blocked;
            document.getElementById('partiallyBlockedCount').textContent = partiallyBlocked;
            document.getElementById('reviewingCount').textContent = reviewing;
        }

        function saveTodayData() {
            const todayData = {
                date: currentDate,
                timestamp: new Date().toISOString(),
                teamData: teamData,
                summary: {
                    total: teamData.length,
                    active: teamData.filter(m => m.status === 'active').length,
                    blocked: teamData.filter(m => m.status === 'blocked').length,
                    partiallyBlocked: teamData.filter(m => m.status === 'partially-blocked').length,
                    reviewing: teamData.filter(m => m.status === 'reviewing').length
                }
            };

            const dataStr = JSON.stringify(todayData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `team-progress-${currentDate}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert(`Today's data saved as: team-progress-${currentDate}.json\nSave this file in your team-data folder.`);
        }

        function saveTodayDataCSV() {
            let csvContent = 'Date,Member Name,Role,Status,Yesterday,Today,Blockers,Notes,Task Title,Task Status,Task Issue,Task Notes\n';
            
            teamData.forEach(member => {
                const baseRow = `"${currentDate}","${member.name}","${member.role}","${member.status}","${(member.yesterday || '').replace(/"/g, '""')}","${(member.today || '').replace(/"/g, '""')}","${(member.blockers || '').replace(/"/g, '""')}","${(member.notes || '').replace(/"/g, '""')}"`;
                
                if (member.tasks && member.tasks.length > 0) {
                    member.tasks.forEach(task => {
                        csvContent += `${baseRow},"${(task.title || '').replace(/"/g, '""')}","${task.status || ''}","${(task.issue || '').replace(/"/g, '""')}","${(task.notes || '').replace(/"/g, '""')}"\n`;
                    });
                } else {
                    csvContent += `${baseRow},"","","",""\n`;
                }
            });

            const dataBlob = new Blob([csvContent], {type: 'text/csv'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `team-progress-${currentDate}.csv`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert(`Today's data saved as CSV: team-progress-${currentDate}.csv`);
        }

        function loadData() {
            const fileInput = document.getElementById('loadDataFile');
            const file = fileInput.files[0];
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    // Check if it's a CSV file by extension or content
                    if (file.name.toLowerCase().endsWith('.csv') || content.startsWith('Date,Member Name,Role')) {
                        loadCSVData(content);
                    } else {
                        // Try to parse as JSON
                        try {
                            const data = JSON.parse(content);
                            if (data.teamData) {
                                teamData = data.teamData;
                                memberIdCounter = Math.max(...teamData.map(m => m.id), 0) + 1;
                                renderTeam();
                                alert(`JSON data loaded from ${data.date || 'unknown date'}`);
                            } else {
                                alert('Invalid JSON file format');
                            }
                        } catch (error) {
                            alert('Error reading file: ' + error.message);
                        }
                    }
                };
                reader.readAsText(file);
            }
            
            // Reset file input
            fileInput.value = '';
        }

        function loadCSVData(csvContent) {
            try {
                const lines = csvContent.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, ''));
                
                if (!headers.includes('Member Name') || !headers.includes('Role')) {
                    alert('Invalid CSV format. Required columns: Member Name, Role');
                    return;
                }
                
                const membersMap = new Map();
                let maxId = 0;
                
                // Parse CSV data
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = parseCSVLine(line);
                    if (values.length < headers.length) continue;
                    
                    const rowData = {};
                    headers.forEach((header, index) => {
                        rowData[header.trim()] = values[index] || '';
                    });
                    
                    const memberName = rowData['Member Name'];
                    if (!memberName) continue;
                    
                    // Initialize member if not exists
                    if (!membersMap.has(memberName)) {
                        maxId++;
                        membersMap.set(memberName, {
                            id: maxId,
                            name: memberName,
                            role: rowData['Role'] || 'Team Member',
                            status: rowData['Status'] || 'active',
                            yesterday: rowData['Yesterday'] || '',
                            today: rowData['Today'] || '',
                            blockers: rowData['Blockers'] || '',
                            notes: rowData['Notes'] || '',
                            tasks: [],
                            lastUpdated: new Date().toISOString()
                        });
                    }
                    
                    // Add task if task data exists
                    const member = membersMap.get(memberName);
                    const taskTitle = rowData['Task Title'];
                    if (taskTitle && taskTitle.trim()) {
                        member.tasks.push({
                            title: taskTitle,
                            status: rowData['Task Status'] || 'active',
                            issue: rowData['Task Issue'] || '',
                            notes: rowData['Task Notes'] || ''
                        });
                    }
                }
                
                teamData = Array.from(membersMap.values());
                memberIdCounter = maxId + 1;
                renderTeam();
                alert(`CSV data loaded successfully! ${teamData.length} team members imported.`);
                
            } catch (error) {
                alert('Error parsing CSV file: ' + error.message);
            }
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i += 2;
                    } else {
                        inQuotes = !inQuotes;
                        i++;
                    }
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                    i++;
                } else {
                    current += char;
                    i++;
                }
            }
            
            values.push(current);
            return values;
        }

        function generateDailySummary() {
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });

            let summary = `DAILY STANDUP SUMMARY - ${dateStr}\n`;
            summary += `=========================================\n\n`;
            summary += `TEAM OVERVIEW:\n`;
            summary += `- Total Team Members: ${teamData.length}\n`;
            summary += `- Active: ${teamData.filter(m => m.status === 'active').length}\n`;
            summary += `- Blocked: ${teamData.filter(m => m.status === 'blocked').length}\n`;
            summary += `- Partially Blocked: ${teamData.filter(m => m.status === 'partially-blocked').length}\n`;
            summary += `- In Review: ${teamData.filter(m => m.status === 'reviewing').length}\n\n`;

            summary += `INDIVIDUAL UPDATES:\n`;
            summary += `==================\n\n`;

            teamData.forEach((member, index) => {
                summary += `${index + 1}. ${member.name.toUpperCase()} (${member.role})\n`;
                summary += `   Status: ${member.status.toUpperCase().replace('-', ' ')}\n`;
                
                if (member.yesterday.trim()) {
                    summary += `   ✅ Yesterday: ${member.yesterday.trim()}\n`;
                }
                
                if (member.today.trim()) {
                    summary += `   🎯 Today: ${member.today.trim()}\n`;
                }
                
                if (member.blockers.trim()) {
                    summary += `   🚧 Blockers: ${member.blockers.trim()}\n`;
                }
                
                if (member.notes.trim()) {
                    summary += `   📝 Notes: ${member.notes.trim()}\n`;
                }
                
                // Add task information
                if (member.tasks && member.tasks.length > 0) {
                    summary += `   📋 Tasks:\n`;
                    member.tasks.forEach((task, taskIndex) => {
                        summary += `     ${taskIndex + 1}. ${task.title} [${task.status.toUpperCase().replace('-', ' ')}]\n`;
                        if (task.issue && task.status !== 'active' && task.status !== 'completed') {
                            summary += `        Issue: ${task.issue}\n`;
                        }
                        if (task.notes && task.notes.trim()) {
                            summary += `        Notes: ${task.notes.trim()}\n`;
                        }
                    });
                }
                
                summary += `\n`;
            });

            // Highlight blockers and important items
            const problematicMembers = teamData.filter(m => 
                m.status === 'blocked' || 
                m.status === 'partially-blocked' || 
                m.blockers.trim()
            );
            if (problematicMembers.length > 0) {
                summary += `ATTENTION REQUIRED:\n`;
                summary += `==================\n`;
                problematicMembers.forEach(member => {
                    if (member.status === 'blocked') {
                        summary += `🔴 ${member.name} is BLOCKED\n`;
                    }
                    if (member.status === 'partially-blocked') {
                        summary += `🟡 ${member.name} is PARTIALLY BLOCKED\n`;
                    }
                    if (member.blockers.trim()) {
                        summary += `⚠️  ${member.name}: ${member.blockers.trim()}\n`;
                    }
                });
                summary += `\n`;
            }

            summary += `AI ANALYSIS PROMPTS:\n`;
            summary += `====================\n`;
            summary += `Please analyze this standup data for:\n`;
            summary += `- Team productivity insights and trends\n`;
            summary += `- Blocker resolution suggestions and priorities\n`;
            summary += `- Resource allocation recommendations\n`;
            summary += `- Risk assessment and mitigation strategies\n`;
            summary += `- Individual performance patterns and support needs\n`;
            summary += `- Team collaboration opportunities\n`;
            summary += `- Overall team health and velocity metrics\n`;

            document.getElementById('summaryContent').textContent = summary;
        }

        function showWeeklySummary() {
            document.getElementById('weeklySummaryModal').style.display = 'block';
        }

        function closeWeeklySummaryModal() {
            document.getElementById('weeklySummaryModal').style.display = 'none';
            document.getElementById('weeklySummaryContent').textContent = 'Select week start date and load daily data files to generate weekly summary...';
            document.getElementById('weeklyDataFiles').value = '';
            weeklyData = [];
        }

        function loadWeeklyFiles() {
            const files = document.getElementById('weeklyDataFiles').files;
            weeklyData = [];
            let filesProcessed = 0;

            if (files.length === 0) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    try {
                        // Check if it's a CSV file
                        if (file.name.toLowerCase().endsWith('.csv') || content.startsWith('Date,Member Name,Role')) {
                            const dailyDataArray = parseCSVToWeeklyData(content, file.name);
                            if (dailyDataArray && Array.isArray(dailyDataArray)) {
                                weeklyData.push(...dailyDataArray);
                            }
                        } else {
                            // Try to parse as JSON
                            const data = JSON.parse(content);
                            if (data.teamData && data.date) {
                                weeklyData.push(data);
                            }
                        }
                    } catch (error) {
                        console.error('Error reading file:', file.name, error);
                    }
                    
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        // Sort by date
                        weeklyData.sort((a, b) => new Date(a.date) - new Date(b.date));
                        updateWeeklyFilesDisplay();
                    }
                };
                reader.readAsText(file);
            });
        }

        function parseCSVToWeeklyData(csvContent, fileName) {
            try {
                const lines = csvContent.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, ''));
                
                if (!headers.includes('Member Name') || !headers.includes('Date')) {
                    console.error('Invalid CSV format for weekly data:', fileName);
                    return null;
                }
                
                // Group data by date
                const dateGroups = new Map();
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = parseCSVLine(line);
                    if (values.length < headers.length) continue;
                    
                    const rowData = {};
                    headers.forEach((header, index) => {
                        rowData[header.trim()] = values[index] || '';
                    });
                    
                    const date = rowData['Date'];
                    const memberName = rowData['Member Name'];
                    
                    if (!date || !memberName) continue;
                    
                    // Initialize date group if not exists
                    if (!dateGroups.has(date)) {
                        dateGroups.set(date, new Map());
                    }
                    
                    const dayMembers = dateGroups.get(date);
                    
                    // Initialize member if not exists
                    if (!dayMembers.has(memberName)) {
                        dayMembers.set(memberName, {
                            id: dayMembers.size + 1,
                            name: memberName,
                            role: rowData['Role'] || 'Team Member',
                            status: rowData['Status'] || 'active',
                            yesterday: rowData['Yesterday'] || '',
                            today: rowData['Today'] || '',
                            blockers: rowData['Blockers'] || '',
                            notes: rowData['Notes'] || '',
                            tasks: [],
                            lastUpdated: new Date().toISOString()
                        });
                    }
                    
                    // Add task if task data exists
                    const member = dayMembers.get(memberName);
                    const taskTitle = rowData['Task Title'];
                    if (taskTitle && taskTitle.trim()) {
                        // Check if task already exists for this member
                        const existingTask = member.tasks.find(t => t.title === taskTitle);
                        if (!existingTask) {
                            member.tasks.push({
                                title: taskTitle,
                                status: rowData['Task Status'] || 'active',
                                issue: rowData['Task Issue'] || '',
                                notes: rowData['Task Notes'] || ''
                            });
                        }
                    }
                }
                
                // Convert to the expected format - create separate entries for each date
                const results = [];
                for (const [date, dayMembers] of dateGroups) {
                    const teamData = Array.from(dayMembers.values());
                    results.push({
                        date: date,
                        timestamp: new Date().toISOString(),
                        teamData: teamData,
                        summary: {
                            total: teamData.length,
                            active: teamData.filter(m => m.status === 'active').length,
                            blocked: teamData.filter(m => m.status === 'blocked').length,
                            partiallyBlocked: teamData.filter(m => m.status === 'partially-blocked').length,
                            reviewing: teamData.filter(m => m.status === 'reviewing').length
                        }
                    });
                }
                
                return results;
                
            } catch (error) {
                console.error('Error parsing CSV for weekly data:', fileName, error);
                return null;
            }
        }

        function updateWeeklyFilesDisplay() {
            const display = document.getElementById('weeklyFiles');
            if (weeklyData.length > 0) {
                display.innerHTML = `<strong>Loaded ${weeklyData.length} daily files:</strong><br>` +
                    weeklyData.map(d => `📅 ${d.date} (${d.teamData.length} members)`).join('<br>');
            } else {
                display.innerHTML = '';
            }
        }

        function generateWeeklySummary() {
            if (weeklyData.length === 0) {
                alert('Please load daily data files first');
                return;
            }

            const weekStart = document.getElementById('weekStartDate').value;
            const startDate = new Date(weekStart);
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 6);

            let summary = `WEEKLY TEAM SUMMARY\n`;
            summary += `Week: ${weekStart} to ${endDate.toISOString().split('T')[0]}\n`;
            summary += `===========================================\n\n`;

            // Weekly overview
            summary += `WEEKLY OVERVIEW:\n`;
            summary += `- Days tracked: ${weeklyData.length}\n`;
            summary += `- Date range: ${weeklyData[0].date} to ${weeklyData[weeklyData.length - 1].date}\n\n`;

            // Daily summaries
            summary += `DAILY BREAKDOWN:\n`;
            summary += `================\n\n`;
            weeklyData.forEach(dayData => {
                const dayName = new Date(dayData.date).toLocaleDateString('en-US', { weekday: 'long' });
                summary += `${dayName} (${dayData.date}):\n`;
                summary += `  Total: ${dayData.summary.total} | Active: ${dayData.summary.active} | `;
                summary += `Blocked: ${dayData.summary.blocked} | Partially Blocked: ${dayData.summary.partiallyBlocked} | Review: ${dayData.summary.reviewing}\n`;
                
                // Highlight blockers for the day
                const blockedMembers = dayData.teamData.filter(m => 
                    m.status === 'blocked' || m.status === 'partially-blocked' || m.blockers.trim()
                );
                if (blockedMembers.length > 0) {
                    summary += `  ⚠️ Issues: ${blockedMembers.map(m => `${m.name}(${m.status})`).join(', ')}\n`;
                }
                summary += `\n`;
            });

            // Team member weekly analysis
            summary += `INDIVIDUAL WEEKLY ANALYSIS:\n`;
            summary += `==========================\n\n`;
            
            const allMembers = new Set();
            weeklyData.forEach(day => {
                day.teamData.forEach(member => allMembers.add(member.name));
            });

            Array.from(allMembers).forEach(memberName => {
                summary += `${memberName.toUpperCase()}:\n`;
                
                const memberDays = weeklyData.map(day => {
                    const member = day.teamData.find(m => m.name === memberName);
                    return member ? {
                        date: day.date,
                        status: member.status,
                        blockers: member.blockers,
                        today: member.today,
                        yesterday: member.yesterday,
                        tasks: member.tasks || [] // Include tasks in the analysis
                    } : null;
                }).filter(Boolean);

                // Status distribution
                const statusCount = {};
                memberDays.forEach(day => {
                    statusCount[day.status] = (statusCount[day.status] || 0) + 1;
                });
                summary += `  Status Distribution: ${Object.entries(statusCount).map(([status, count]) => `${status}(${count}d)`).join(', ')}\n`;

                // Days with blockers
                const blockedDays = memberDays.filter(day => day.status.includes('blocked') || day.blockers.trim());
                if (blockedDays.length > 0) {
                    summary += `  🚧 Blocked Days: ${blockedDays.length}/${memberDays.length}\n`;
                    blockedDays.forEach(day => {
                        if (day.blockers.trim()) {
                            summary += `    ${day.date}: ${day.blockers.trim()}\n`;
                        }
                    });
                }

                // Task progress analysis
                const allTasks = [];
                memberDays.forEach(day => {
                    day.tasks.forEach(task => {
                        // Only add unique tasks (by title) to avoid duplicates
                        if (!allTasks.some(t => t.title === task.title)) {
                            allTasks.push({
                                title: task.title,
                                statusHistory: [{date: day.date, status: task.status}],
                                latestNotes: task.notes || '',
                                latestIssue: task.issue || ''
                            });
                        } else {
                            const existingTask = allTasks.find(t => t.title === task.title);
                            existingTask.statusHistory.push({date: day.date, status: task.status});
                            // Update with latest notes and issue
                            if (task.notes) existingTask.latestNotes = task.notes;
                            if (task.issue) existingTask.latestIssue = task.issue;
                        }
                    });
                });
                
                if (allTasks.length > 0) {
                    summary += `  📋 Task Progress:\n`;
                    allTasks.forEach(task => {
                        const statusChanges = task.statusHistory.map(h => `${h.date}: ${h.status}`).join(' → ');
                        summary += `    ${task.title}: ${statusChanges}\n`;
                        if (task.latestIssue && task.latestIssue.trim()) {
                            summary += `      Latest Issue: ${task.latestIssue.trim()}\n`;
                        }
                        if (task.latestNotes && task.latestNotes.trim()) {
                            summary += `      Latest Notes: ${task.latestNotes.trim()}\n`;
                        }
                    });
                }

                // Recent accomplishments and tasks
                const recentWork = memberDays.slice(-2);
                if (recentWork.length > 0) {
                    summary += `  📈 Recent Progress:\n`;
                    recentWork.forEach(day => {
                        if (day.today.trim()) {
                            summary += `    ${day.date}: ${day.today.trim()}\n`;
                        }
                    });
                }
                summary += `\n`;
            });

            // Weekly insights and trends
            summary += `WEEKLY INSIGHTS & TRENDS:\n`;
            summary += `========================\n\n`;

            // Calculate trends
            const dailyBlockedCounts = weeklyData.map(day => 
                day.summary.blocked + day.summary.partiallyBlocked
            );
            const avgBlocked = (dailyBlockedCounts.reduce((a, b) => a + b, 0) / dailyBlockedCounts.length).toFixed(1);
            
            const dailyActiveCounts = weeklyData.map(day => day.summary.active);
            const avgActive = (dailyActiveCounts.reduce((a, b) => a + b, 0) / dailyActiveCounts.length).toFixed(1);

            summary += `📊 METRICS:\n`;
            summary += `- Average daily active members: ${avgActive}\n`;
            summary += `- Average daily blocked members: ${avgBlocked}\n`;
            summary += `- Peak performance day: ${weeklyData[dailyActiveCounts.indexOf(Math.max(...dailyActiveCounts))].date}\n`;
            summary += `- Most challenging day: ${weeklyData[dailyBlockedCounts.indexOf(Math.max(...dailyBlockedCounts))].date}\n\n`;

            // Common blockers analysis
            const allBlockers = [];
            weeklyData.forEach(day => {
                day.teamData.forEach(member => {
                    if (member.blockers.trim()) {
                        allBlockers.push(member.blockers.trim().toLowerCase());
                    }
                });
            });

            if (allBlockers.length > 0) {
                summary += `🔍 COMMON BLOCKER PATTERNS:\n`;
                const blockerFreq = {};
                allBlockers.forEach(blocker => {
                    const words = blocker.split(' ').filter(word => word.length > 3);
                    words.forEach(word => {
                        blockerFreq[word] = (blockerFreq[word] || 0) + 1;
                    });
                });
                const topBlockers = Object.entries(blockerFreq)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([word, count]) => `${word}(${count}x)`)
                    .join(', ');
                summary += `- Frequent blocker keywords: ${topBlockers}\n\n`;
            }

            summary += `AI WEEKLY ANALYSIS PROMPTS:\n`;
            summary += `===========================\n`;
            summary += `Based on this weekly data, please provide:\n`;
            summary += `1. Team velocity and productivity analysis\n`;
            summary += `2. Blocker pattern analysis and prevention strategies\n`;
            summary += `3. Individual performance insights and development recommendations\n`;
            summary += `4. Resource allocation and workload distribution suggestions\n`;
            summary += `5. Team collaboration and communication improvements\n`;
            summary += `6. Sprint planning recommendations for next week\n`;
            summary += `7. Risk assessment for upcoming deliverables\n`;
            summary += `8. Process improvement suggestions based on recurring issues\n`;
            summary += `9. Team morale and engagement indicators\n`;
            summary += `10. Long-term trend analysis and strategic recommendations\n`;

            document.getElementById('weeklySummaryContent').textContent = summary;
        }

        function copySummary() {
            const summaryContent = document.getElementById('summaryContent').textContent;
            if (summaryContent === "Click \"Daily Summary\" to create an AI-ready report of today's progress...") {
                alert('Please generate a daily summary first!');
                return;
            }

            navigator.clipboard.writeText(summaryContent).then(() => {
                alert('Daily summary copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy. Please select and copy manually.');
            });
        }

        function copyWeeklySummary() {
            const summaryContent = document.getElementById('weeklySummaryContent').textContent;
            if (summaryContent === "Select week start date and load daily data files to generate weekly summary...") {
                alert('Please generate a weekly summary first!');
                return;
            }

            navigator.clipboard.writeText(summaryContent).then(() => {
                alert('Weekly summary copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy. Please select and copy manually.');
            });
        }

        function exportSummary() {
            const summaryContent = document.getElementById('summaryContent').textContent;
            if (summaryContent === "Click \"Daily Summary\" to create an AI-ready report of today's progress...") {
                alert('Please generate a daily summary first!');
                return;
            }

            const dataBlob = new Blob([summaryContent], {type: 'text/plain'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `daily-summary-${currentDate}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportWeeklySummary() {
            const summaryContent = document.getElementById('weeklySummaryContent').textContent;
            if (summaryContent === "Select week start date and load daily data files to generate weekly summary...") {
                alert('Please generate a weekly summary first!');
                return;
            }

            const weekStart = document.getElementById('weekStartDate').value;
            const dataBlob = new Blob([summaryContent], {type: 'text/plain'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `weekly-summary-${weekStart}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportWeeklySummaryCSV() {
            if (weeklyData.length === 0) {
                alert('Please load weekly data first!');
                return;
            }

            const weekStart = document.getElementById('weekStartDate').value;
            let csvContent = 'Date,Member Name,Role,Status,Yesterday,Today,Blockers,Notes,Task Title,Task Status,Task Issue,Task Notes,Day of Week\n';
            
            weeklyData.forEach(dayData => {
                const dayName = new Date(dayData.date).toLocaleDateString('en-US', { weekday: 'long' });
                
                dayData.teamData.forEach(member => {
                    const baseRow = `"${dayData.date}","${member.name}","${member.role}","${member.status}","${(member.yesterday || '').replace(/"/g, '""')}","${(member.today || '').replace(/"/g, '""')}","${(member.blockers || '').replace(/"/g, '""')}","${(member.notes || '').replace(/"/g, '""')}"`;
                    
                    if (member.tasks && member.tasks.length > 0) {
                        member.tasks.forEach(task => {
                            csvContent += `${baseRow},"${(task.title || '').replace(/"/g, '""')}","${task.status || ''}","${(task.issue || '').replace(/"/g, '""')}","${(task.notes || '').replace(/"/g, '""')}","${dayName}"\n`;
                        });
                    } else {
                        csvContent += `${baseRow},"","","","","${dayName}"\n`;
                    }
                });
            });

            const dataBlob = new Blob([csvContent], {type: 'text/csv'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `weekly-data-${weekStart}.csv`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert(`Weekly data exported as CSV: weekly-data-${weekStart}.csv`);
        }

        function clearToday() {
            if (confirm('Are you sure you want to clear today\'s data? This will remove all progress notes but keep team members.')) {
                teamData.forEach(member => {
                    member.yesterday = '';
                    member.today = '';
                    member.blockers = '';
                    member.notes = '';
                    member.status = 'active';
                    // Clear task details but keep the tasks
                    if (member.tasks) {
                        member.tasks.forEach(task => {
                            task.status = 'active';
                            task.issue = '';
                            task.notes = '';
                        });
                    }
                    member.lastUpdated = new Date().toISOString();
                });
                renderTeam();
                document.getElementById('summaryContent').textContent = "Click \"Daily Summary\" to create an AI-ready report of today's progress...";
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const memberModal = document.getElementById('memberModal');
            const weeklyModal = document.getElementById('weeklySummaryModal');
            const taskStateModal = document.getElementById('taskStateModal');
            if (event.target === memberModal) {
                closeMemberModal();
            }
            if (event.target === weeklyModal) {
                closeWeeklySummaryModal();
            }
            if (event.target === taskStateModal) {
                closeTaskStateModal();
            }
        }

        // Load sample data from external file
        function loadSampleData() {
            teamData = initializeSampleData();
            memberIdCounter = TEAM_CONFIG.startingMemberIdCounter;
            renderTeam();
        }

        // Load sample data on first visit
        if (teamData.length === 0) {
            loadSampleData();
        }

        // Task State Analysis Functions
        let taskStateData = [];

        function showTaskStateAnalysis() {
            document.getElementById('taskStateModal').style.display = 'block';
        }

        function closeTaskStateModal() {
            document.getElementById('taskStateModal').style.display = 'none';
            document.getElementById('taskStateContent').textContent = 'Load historical data files and click "Analyze Tasks" to generate comprehensive task state analysis for GenAI...';
            document.getElementById('taskStateDataFiles').value = '';
            document.getElementById('taskStateFiles').innerHTML = '';
            taskStateData = [];
        }

        function loadTaskStateFiles() {
            const files = document.getElementById('taskStateDataFiles').files;
            taskStateData = [];
            let filesProcessed = 0;

            if (files.length === 0) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    try {
                        // Check if it's a CSV file
                        if (file.name.toLowerCase().endsWith('.csv') || content.startsWith('Date,Member Name,Role')) {
                            const dailyDataArray = parseCSVToWeeklyData(content, file.name);
                            if (dailyDataArray && Array.isArray(dailyDataArray)) {
                                taskStateData.push(...dailyDataArray);
                            }
                        } else {
                            // Try to parse as JSON
                            const data = JSON.parse(content);
                            if (data.teamData && data.date) {
                                taskStateData.push(data);
                            }
                        }
                    } catch (error) {
                        console.error('Error reading file:', file.name, error);
                    }
                    
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        // Sort by date
                        taskStateData.sort((a, b) => new Date(a.date) - new Date(b.date));
                        updateTaskStateFilesDisplay();
                    }
                };
                reader.readAsText(file);
            });
        }

        function updateTaskStateFilesDisplay() {
            const display = document.getElementById('taskStateFiles');
            if (taskStateData.length > 0) {
                const dateRange = taskStateData.length > 1 ? 
                    `${taskStateData[0].date} to ${taskStateData[taskStateData.length - 1].date}` : 
                    taskStateData[0].date;
                display.innerHTML = `<strong>📅 Loaded ${taskStateData.length} daily files:</strong><br>` +
                    `<span style="color: #666;">Date Range: ${dateRange}</span><br>` +
                    taskStateData.map(d => `📊 ${d.date} (${d.teamData.length} members, ${d.teamData.reduce((total, m) => total + (m.tasks ? m.tasks.length : 0), 0)} tasks)`).join('<br>');
            } else {
                display.innerHTML = '';
            }
        }

        function generateTaskStateAnalysis() {
            if (taskStateData.length === 0) {
                alert('Please load historical data files first');
                return;
            }

            const analysis = analyzeTaskStates();
            document.getElementById('taskStateContent').textContent = analysis;
        }

        function generateCurrentTaskSummary() {
            if (taskStateData.length === 0) {
                alert('Please load historical data files first');
                return;
            }

            const summary = generateCurrentStateSummary();
            document.getElementById('taskStateContent').textContent = summary;
        }

        function generateTechnicalTaskAnalysis() {
            if (taskStateData.length === 0) {
                alert('Please load historical data files first');
                return;
            }

            const analysis = generateTechnicalAnalysis();
            document.getElementById('taskStateContent').textContent = analysis;
        }

        function analyzeTaskStates() {
            const now = new Date();
            const dateRange = taskStateData.length > 1 ? 
                `${taskStateData[0].date} to ${taskStateData[taskStateData.length - 1].date}` : 
                taskStateData[0].date;

            let analysis = `COMPREHENSIVE TASK STATE ANALYSIS - ${now.toLocaleDateString()}\n`;
            analysis += `=================================================================\n\n`;
            analysis += `DATA OVERVIEW:\n`;
            analysis += `- Analysis Period: ${dateRange}\n`;
            analysis += `- Total Days Analyzed: ${taskStateData.length}\n`;
            analysis += `- Total Data Points: ${taskStateData.reduce((total, d) => total + d.teamData.length, 0)}\n`;
            analysis += `- Total Tasks Tracked: ${taskStateData.reduce((total, d) => total + d.teamData.reduce((taskTotal, m) => taskTotal + (m.tasks ? m.tasks.length : 0), 0), 0)}\n\n`;

            // Build comprehensive task timeline
            const taskTimelines = buildTaskTimelines();
            
            analysis += `TASK EVOLUTION ANALYSIS:\n`;
            analysis += `========================\n\n`;

            // Analyze each unique task across all team members
            Object.entries(taskTimelines).forEach(([memberName, memberTasks]) => {
                analysis += `${memberName.toUpperCase()}:\n`;
                analysis += `${'='.repeat(memberName.length + 1)}\n`;
                
                Object.entries(memberTasks).forEach(([taskTitle, timeline]) => {
                    analysis += `\n📋 TASK: ${taskTitle}\n`;
                    analysis += `${'-'.repeat(taskTitle.length + 8)}\n`;
                    
                    // Timeline analysis
                    analysis += `🕐 TIMELINE (${timeline.length} entries):\n`;
                    timeline.forEach((entry, index) => {
                        const statusChange = index > 0 && entry.status !== timeline[index - 1].status ? 
                            ` [CHANGED FROM ${timeline[index - 1].status.toUpperCase()}]` : '';
                        analysis += `  ${entry.date}: ${entry.status.toUpperCase()}${statusChange}\n`;
                        if (entry.notes && entry.notes.trim()) {
                            analysis += `    📝 Notes: ${entry.notes.trim()}\n`;
                        }
                        if (entry.issue && entry.issue.trim()) {
                            analysis += `    ⚠️ Issue: ${entry.issue.trim()}\n`;
                        }
                    });

                    // Task insights
                    const latestEntry = timeline[timeline.length - 1];
                    const firstEntry = timeline[0];
                    const daysSinceStart = Math.ceil((new Date(latestEntry.date) - new Date(firstEntry.date)) / (1000 * 60 * 60 * 24)) + 1;
                    const statusChanges = timeline.reduce((changes, entry, index) => 
                        index > 0 && entry.status !== timeline[index - 1].status ? changes + 1 : changes, 0);
                    
                    analysis += `\n🔍 TASK INSIGHTS:\n`;
                    analysis += `  • Current Status: ${latestEntry.status.toUpperCase()}\n`;
                    analysis += `  • Days in Progress: ${daysSinceStart}\n`;
                    analysis += `  • Status Changes: ${statusChanges}\n`;
                    analysis += `  • Stability: ${statusChanges === 0 ? 'STABLE' : statusChanges <= 2 ? 'MODERATE' : 'HIGH VOLATILITY'}\n`;
                    
                    // Pattern detection
                    const blockedDays = timeline.filter(e => e.status.includes('blocked')).length;
                    const activeDays = timeline.filter(e => e.status === 'active').length;
                    const reviewDays = timeline.filter(e => e.status === 'reviewing').length;
                    const completedDays = timeline.filter(e => e.status === 'completed').length;
                    
                    analysis += `  • Activity Pattern: Active(${activeDays}d), Blocked(${blockedDays}d), Review(${reviewDays}d), Completed(${completedDays}d)\n`;
                    
                    if (blockedDays > 0) {
                        const blockageRate = ((blockedDays / timeline.length) * 100).toFixed(1);
                        analysis += `  • Blockage Rate: ${blockageRate}% (${blockedDays}/${timeline.length} days)\n`;
                    }

                    // Risk assessment
                    if (latestEntry.status.includes('blocked')) {
                        analysis += `  🚨 RISK: Currently blocked - requires immediate attention\n`;
                    } else if (daysSinceStart > 7 && statusChanges > 3) {
                        analysis += `  ⚠️ RISK: Long duration with multiple status changes - may need reassessment\n`;
                    } else if (blockedDays > activeDays && latestEntry.status === 'active') {
                        analysis += `  ⚠️ RISK: More blocked days than active - monitor closely\n`;
                    }

                    // Get task understanding if available
                    if (latestEntry.understanding) {
                        analysis += `\n🧠 TASK UNDERSTANDING:\n`;
                        analysis += `  Summary: ${latestEntry.understanding.summary}\n`;
                        analysis += `  Technical Context: ${latestEntry.understanding.technicalContext}\n`;
                        analysis += `  Business Impact: ${latestEntry.understanding.businessImpact}\n`;
                        analysis += `  Estimated Effort: ${latestEntry.understanding.estimatedEffort}\n`;
                        analysis += `  Required Skills: ${latestEntry.understanding.skillsRequired.join(', ')}\n`;
                        if (latestEntry.understanding.dependencies && latestEntry.understanding.dependencies.length > 0) {
                            analysis += `  Dependencies: ${latestEntry.understanding.dependencies.join(', ')}\n`;
                        }
                    }

                    analysis += `\n`;
                });
                analysis += `\n`;
            });

            // Team-wide task analytics
            analysis += `TEAM-WIDE TASK ANALYTICS:\n`;
            analysis += `========================\n\n`;
            
            const teamStats = calculateTeamTaskStats(taskTimelines);
            analysis += `📊 OVERALL METRICS:\n`;
            analysis += `  • Total Unique Tasks: ${teamStats.totalTasks}\n`;
            analysis += `  • Currently Active Tasks: ${teamStats.activeTasks}\n`;
            analysis += `  • Currently Blocked Tasks: ${teamStats.blockedTasks}\n`;
            analysis += `  • Tasks in Review: ${teamStats.reviewTasks}\n`;
            analysis += `  • Completed Tasks: ${teamStats.completedTasks}\n`;
            analysis += `  • Average Task Duration: ${teamStats.avgDuration.toFixed(1)} days\n`;
            analysis += `  • Team Velocity: ${teamStats.velocity.toFixed(1)} tasks/day\n`;
            analysis += `  • Task Completion Rate: ${teamStats.completionRate.toFixed(1)}%\n\n`;

            // Blocker analysis
            const blockerPatterns = analyzeBlockerPatterns();
            if (blockerPatterns.length > 0) {
                analysis += `🚧 BLOCKER PATTERN ANALYSIS:\n`;
                blockerPatterns.forEach(pattern => {
                    analysis += `  • "${pattern.keyword}": ${pattern.frequency} occurrences across ${pattern.tasks} tasks\n`;
                    analysis += `    Affected members: ${pattern.members.join(', ')}\n`;
                    analysis += `    Avg resolution time: ${pattern.avgResolutionDays.toFixed(1)} days\n\n`;
                });
            }

            // AI prompts for GenAI
            analysis += `GENAI ANALYSIS PROMPTS:\n`;
            analysis += `======================\n`;
            analysis += `Based on this comprehensive task state analysis, please provide:\n\n`;
            analysis += `1. TASK PRIORITIZATION:\n`;
            analysis += `   - Which tasks need immediate attention and why?\n`;
            analysis += `   - What's the optimal task sequence for each team member?\n`;
            analysis += `   - Which tasks are at risk of missing deadlines?\n\n`;
            
            analysis += `2. RESOURCE OPTIMIZATION:\n`;
            analysis += `   - Are team members working on tasks matching their skillsets?\n`;
            analysis += `   - Where should we reallocate resources for better efficiency?\n`;
            analysis += `   - Which team members need additional support or training?\n\n`;
            
            analysis += `3. BLOCKER RESOLUTION:\n`;
            analysis += `   - What are the root causes of recurring blockers?\n`;
            analysis += `   - Which blockers have the highest impact on team velocity?\n`;
            analysis += `   - What preventive measures can reduce future blockages?\n\n`;
            
            analysis += `4. PROCESS IMPROVEMENT:\n`;
            analysis += `   - What patterns indicate process inefficiencies?\n`;
            analysis += `   - Which tasks have optimal completion patterns to replicate?\n`;
            analysis += `   - How can we improve task estimation and planning?\n\n`;
            
            analysis += `5. RISK ASSESSMENT:\n`;
            analysis += `   - Which projects/deliverables are at highest risk?\n`;
            analysis += `   - What early warning signs should we monitor?\n`;
            analysis += `   - Which dependencies pose the greatest threat to timelines?\n\n`;
            
            analysis += `6. PERFORMANCE INSIGHTS:\n`;
            analysis += `   - How is each team member performing relative to their capacity?\n`;
            analysis += `   - What are the optimal task types for each individual?\n`;
            analysis += `   - Where do we see signs of burnout or underutilization?\n\n`;
            
            analysis += `7. STRATEGIC RECOMMENDATIONS:\n`;
            analysis += `   - What changes would most improve team productivity?\n`;
            analysis += `   - How should we adjust sprint planning based on these insights?\n`;
            analysis += `   - What skills gaps need to be addressed for future tasks?\n`;

            return analysis;
        }

        function buildTaskTimelines() {
            const taskTimelines = {};
            
            taskStateData.forEach(dayData => {
                dayData.teamData.forEach(member => {
                    if (!taskTimelines[member.name]) {
                        taskTimelines[member.name] = {};
                    }
                    
                    if (member.tasks && member.tasks.length > 0) {
                        member.tasks.forEach(task => {
                            if (!task.title || task.title.trim() === '') return;
                            
                            if (!taskTimelines[member.name][task.title]) {
                                taskTimelines[member.name][task.title] = [];
                            }
                            
                            taskTimelines[member.name][task.title].push({
                                date: dayData.date,
                                status: task.status || 'unknown',
                                notes: task.notes || '',
                                issue: task.issue || '',
                                nextSteps: task.nextSteps || '',
                                understanding: task.understanding || null
                            });
                        });
                    }
                });
            });
            
            return taskTimelines;
        }

        function calculateTeamTaskStats(taskTimelines) {
            let totalTasks = 0;
            let activeTasks = 0;
            let blockedTasks = 0;
            let reviewTasks = 0;
            let completedTasks = 0;
            let totalDuration = 0;
            let taskCount = 0;
            
            Object.values(taskTimelines).forEach(memberTasks => {
                Object.values(memberTasks).forEach(timeline => {
                    totalTasks++;
                    taskCount++;
                    
                    const latestEntry = timeline[timeline.length - 1];
                    const firstEntry = timeline[0];
                    const duration = Math.ceil((new Date(latestEntry.date) - new Date(firstEntry.date)) / (1000 * 60 * 60 * 24)) + 1;
                    totalDuration += duration;
                    
                    switch (latestEntry.status) {
                        case 'active':
                            activeTasks++;
                            break;
                        case 'blocked':
                        case 'partially-blocked':
                            blockedTasks++;
                            break;
                        case 'reviewing':
                            reviewTasks++;
                            break;
                        case 'completed':
                            completedTasks++;
                            break;
                    }
                });
            });
            
            const avgDuration = taskCount > 0 ? totalDuration / taskCount : 0;
            const velocity = taskStateData.length > 0 ? completedTasks / taskStateData.length : 0;
            const completionRate = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
            
            return {
                totalTasks,
                activeTasks,
                blockedTasks,
                reviewTasks,
                completedTasks,
                avgDuration,
                velocity,
                completionRate
            };
        }

        function analyzeBlockerPatterns() {
            const blockerData = {};
            
            taskStateData.forEach(dayData => {
                dayData.teamData.forEach(member => {
                    if (member.tasks) {
                        member.tasks.forEach(task => {
                            if (task.issue && task.issue.trim()) {
                                const keywords = task.issue.toLowerCase().split(/[\s,.-]+/)
                                    .filter(word => word.length > 3);
                                
                                keywords.forEach(keyword => {
                                    if (!blockerData[keyword]) {
                                        blockerData[keyword] = {
                                            frequency: 0,
                                            tasks: new Set(),
                                            members: new Set(),
                                            dates: []
                                        };
                                    }
                                    
                                    blockerData[keyword].frequency++;
                                    blockerData[keyword].tasks.add(task.title);
                                    blockerData[keyword].members.add(member.name);
                                    blockerData[keyword].dates.push(dayData.date);
                                });
                            }
                        });
                    }
                });
            });
            
            return Object.entries(blockerData)
                .filter(([keyword, data]) => data.frequency >= 2)
                .map(([keyword, data]) => ({
                    keyword,
                    frequency: data.frequency,
                    tasks: data.tasks.size,
                    members: Array.from(data.members),
                    avgResolutionDays: data.dates.length > 1 ? 
                        (new Date(Math.max(...data.dates.map(d => new Date(d)))) - 
                         new Date(Math.min(...data.dates.map(d => new Date(d))))) / (1000 * 60 * 60 * 24) / data.frequency : 0
                }))
                .sort((a, b) => b.frequency - a.frequency);
        }

        function generateCurrentStateSummary() {
            if (taskStateData.length === 0) return '';
            
            // Get the most recent data (files are already sorted by date)
            const latestData = taskStateData[taskStateData.length - 1];
            const now = new Date();
            
            // Build task timeline to get latest comments
            const taskTimelines = buildTaskTimelines();
            
            let summary = `CURRENT TASK STATE SUMMARY - ${latestData.date}\n`;
            summary += `=============================================\n\n`;
            
            summary += `📊 CURRENT SNAPSHOT:\n`;
            summary += `- As of: ${latestData.date}\n`;
            summary += `- Team Members: ${latestData.teamData.length}\n`;
            summary += `- Total Active Tasks: ${latestData.teamData.reduce((total, m) => total + (m.tasks ? m.tasks.length : 0), 0)}\n\n`;
            
            summary += `👥 INDIVIDUAL CURRENT STATES:\n`;
            summary += `=============================\n\n`;
            
            latestData.teamData.forEach(member => {
                summary += `${member.name.toUpperCase()} (${member.role}):\n`;
                summary += `Status: ${member.status.toUpperCase()}\n`;
                
                if (member.blockers && member.blockers.trim()) {
                    summary += `🚧 Current Blockers: ${member.blockers.trim()}\n`;
                }
                
                if (member.tasks && member.tasks.length > 0) {
                    member.tasks.forEach((task, index) => {
                        summary += `\n${index + 1}. TASK DETAILS:\n`;
                        summary += `${'='.repeat(20)}\n`;
                        
                        // Task Title
                        summary += `Task Title:\n${task.title}\n\n`;
                        
                        // Primary Language
                        const primaryLang = task.understanding?.primaryLanguage || 'Not specified';
                        summary += `Primary language:\n${primaryLang}\n\n`;
                        
                        // Secondary Language
                        const secondaryLang = task.understanding?.secondaryLanguage || 'N/A';
                        summary += `Secondary language:\n${secondaryLang}\n\n`;
                        
                        // Task Description
                        const taskDesc = task.understanding?.taskDescription || task.understanding?.summary || 'No description available';
                        summary += `Task Description:\n${taskDesc}\n\n`;
                        
                        // Requirements
                        summary += `Requirements:\n`;
                        if (task.understanding?.requirements && task.understanding.requirements.length > 0) {
                            task.understanding.requirements.forEach(req => {
                                summary += `${req}\n`;
                            });
                        } else {
                            summary += `No specific requirements documented\n`;
                        }
                        summary += `\n`;
                        
                        // Latest user comment (from most recent file based on date)
                        let latestComment = 'No recent comments';
                        if (taskTimelines[member.name] && taskTimelines[member.name][task.title]) {
                            const timeline = taskTimelines[member.name][task.title];
                            // Get the most recent entry with notes
                            for (let i = timeline.length - 1; i >= 0; i--) {
                                if (timeline[i].notes && timeline[i].notes.trim()) {
                                    latestComment = timeline[i].notes.trim();
                                    break;
                                }
                            }
                        } else if (task.notes && task.notes.trim()) {
                            latestComment = task.notes.trim();
                        }
                        summary += `Latest user comment:\n${latestComment}\n\n`;
                        
                        // Next Steps
                        const nextSteps = task.nextSteps && task.nextSteps.trim() ? task.nextSteps.trim() : 'No next steps defined';
                        summary += `Next Steps:\n${nextSteps}\n\n`;
                        
                        summary += `\n${'-'.repeat(50)}\n`;
                    });
                } else {
                    summary += `📋 No specific tasks tracked\n`;
                }
                
                summary += `\n`;
            });
            
            // Immediate attention items
            const urgentItems = [];
            latestData.teamData.forEach(member => {
                if (member.status === 'blocked') {
                    urgentItems.push(`🔴 ${member.name} is BLOCKED`);
                }
                if (member.tasks) {
                    member.tasks.forEach(task => {
                        if (task.status === 'blocked') {
                            urgentItems.push(`🔴 ${member.name}: "${task.title}" is BLOCKED`);
                        }
                    });
                }
            });
            
            if (urgentItems.length > 0) {
                summary += `🚨 REQUIRES IMMEDIATE ATTENTION:\n`;
                summary += `================================\n`;
                urgentItems.forEach(item => {
                    summary += `${item}\n`;
                });
                summary += `\n`;
            }
            
            summary += `🤖 GENAI EMAIL DRAFT GENERATION PROMPTS:\n`;
            summary += `==========================================\n`;
            summary += `Based on this comprehensive task state snapshot, please generate a professional email draft that provides a clear, understandable current status report for every task.\n\n`;
            summary += `EMAIL REQUIREMENTS:\n`;
            summary += `- Create a well-structured email with proper subject line and professional tone\n`;
            summary += `- Provide a simple, understandable summary for each task's current state\n`;
            summary += `- Highlight necessary points, blockers, and critical issues that need attention\n`;
            summary += `- Include clear next steps and actionable items for each task\n`;
            summary += `- Mention Task Notes/Current Status details when they contain important highlights\n`;
            summary += `- Organize information in a scannable format suitable for stakeholders\n`;
            summary += `- Include priority levels and any urgent items requiring immediate action\n\n`;
            summary += `Please generate a complete email draft ready to send to project stakeholders.\n`;
            
            return summary;
        }

        function generateTechnicalAnalysis() {
            if (taskStateData.length === 0) return '';
            
            // Get the most recent data (files are already sorted by date)
            const latestData = taskStateData[taskStateData.length - 1];
            const now = new Date();
            
            // Build task timeline to get latest information
            const taskTimelines = buildTaskTimelines();
            
            let analysis = `TECHNICAL TASK STATUS ANALYSIS - ${latestData.date}\n`;
            analysis += `=====================================================\n\n`;
            
            analysis += `📋 COMPREHENSIVE TECHNICAL BREAKDOWN:\n`;
            analysis += `=====================================\n\n`;
            
            latestData.teamData.forEach(member => {
                analysis += `👤 ${member.name.toUpperCase()} (${member.role}):\n`;
                analysis += `${'='.repeat(member.name.length + member.role.length + 4)}\n\n`;
                
                if (member.tasks && member.tasks.length > 0) {
                    member.tasks.forEach((task, index) => {
                        analysis += `🔧 TASK ${index + 1}: ${task.title}\n`;
                        analysis += `${'-'.repeat(task.title.length + 10)}\n`;
                        
                        // Technical Overview
                        if (task.understanding) {
                            analysis += `📊 TECHNICAL OVERVIEW:\n`;
                            analysis += `Primary Technology: ${task.understanding.primaryLanguage || 'Not specified'}\n`;
                            analysis += `Secondary Technology: ${task.understanding.secondaryLanguage || 'N/A'}\n`;
                            analysis += `Technical Context: ${task.understanding.technicalContext || 'Not specified'}\n\n`;
                            
                            analysis += `🎯 TASK PURPOSE & SCOPE:\n`;
                            analysis += `${task.understanding.taskDescription || task.understanding.summary || 'No description available'}\n\n`;
                            
                            if (task.understanding.requirements && task.understanding.requirements.length > 0) {
                                analysis += `📋 TECHNICAL REQUIREMENTS:\n`;
                                task.understanding.requirements.forEach((req, reqIndex) => {
                                    analysis += `${reqIndex + 1}. ${req}\n`;
                                });
                                analysis += `\n`;
                            }
                        }
                        
                        // Current Status Analysis
                        analysis += `📈 CURRENT STATUS ANALYSIS:\n`;
                        analysis += `Status: ${task.status.toUpperCase()}\n`;
                        
                        if (task.progressMetrics) {
                            const progress = task.progressMetrics;
                            const efficiency = progress.estimatedHours > 0 ? 
                                ((progress.hoursSpent / progress.estimatedHours) * 100).toFixed(1) : 0;
                            analysis += `Progress: ${progress.completionPercentage}% complete\n`;
                            analysis += `Time Utilization: ${progress.hoursSpent}/${progress.estimatedHours} hours (${efficiency}% of estimate)\n`;
                            analysis += `Remaining Effort: ${progress.estimatedHours - progress.hoursSpent} hours\n`;
                        }
                        
                        if (task.priority) {
                            analysis += `Priority Level: ${task.priority.toUpperCase()}\n`;
                        }
                        if (task.complexity) {
                            analysis += `Technical Complexity: ${task.complexity.toUpperCase()}\n`;
                        }
                        if (task.riskLevel) {
                            analysis += `Risk Assessment: ${task.riskLevel.toUpperCase()}\n`;
                        }
                        analysis += `\n`;
                        
                        // Technical Progress Notes
                        if (task.notes && task.notes.trim()) {
                            analysis += `💬 CURRENT TECHNICAL PROGRESS:\n`;
                            analysis += `${task.notes.trim()}\n\n`;
                        }
                        
                        // Blockers & Issues
                        if (task.issue && task.issue.trim()) {
                            analysis += `🚫 TECHNICAL BLOCKERS:\n`;
                            analysis += `${task.issue.trim()}\n\n`;
                        }
                        
                        // Next Steps
                        if (task.nextSteps && task.nextSteps.trim()) {
                            analysis += `🎯 NEXT TECHNICAL STEPS:\n`;
                            analysis += `${task.nextSteps.trim()}\n\n`;
                        }
                        
                        // Dependencies Analysis
                        if (task.understanding?.dependencies && task.understanding.dependencies.length > 0) {
                            analysis += `🔗 TECHNICAL DEPENDENCIES:\n`;
                            task.understanding.dependencies.forEach(dep => {
                                analysis += `- ${dep}\n`;
                            });
                            analysis += `\n`;
                        }
                        
                        // Skills Required
                        if (task.understanding?.skillsRequired && task.understanding.skillsRequired.length > 0) {
                            analysis += `🛠️ REQUIRED TECHNICAL SKILLS:\n`;
                            analysis += `${task.understanding.skillsRequired.join(', ')}\n\n`;
                        }
                        
                        // Historical Progress (if available)
                        if (taskTimelines[member.name] && taskTimelines[member.name][task.title]) {
                            const timeline = taskTimelines[member.name][task.title];
                            if (timeline.length > 1) {
                                analysis += `📊 PROGRESS TIMELINE:\n`;
                                timeline.slice(-3).forEach(entry => {
                                    analysis += `${entry.date}: Status was ${entry.status.toUpperCase()}`;
                                    if (entry.notes && entry.notes.trim()) {
                                        analysis += ` - ${entry.notes.trim().substring(0, 100)}${entry.notes.length > 100 ? '...' : ''}`;
                                    }
                                    analysis += `\n`;
                                });
                                analysis += `\n`;
                            }
                        }
                        
                        analysis += `${'-'.repeat(60)}\n\n`;
                    });
                } else {
                    analysis += `📝 No specific technical tasks currently tracked for this team member.\n\n`;
                }
                
                analysis += `\n`;
            });
            
            // Technical AI Prompts
            analysis += `🤖 TECHNICAL AI ANALYSIS PROMPTS:\n`;
            analysis += `=================================\n`;
            analysis += `Based on this detailed technical task analysis, please provide comprehensive insights on:\n\n`;
            
            analysis += `🔍 TASK-SPECIFIC TECHNICAL ANALYSIS:\n`;
            analysis += `For each task above, please provide a detailed paragraph explaining:\n`;
            analysis += `- Current technical status and what has been accomplished so far\n`;
            analysis += `- Technical challenges and complexity assessment based on requirements\n`;
            analysis += `- Code/implementation approach and architecture decisions\n`;
            analysis += `- Integration points and technical dependencies analysis\n`;
            analysis += `- Potential technical risks and mitigation strategies\n`;
            analysis += `- Performance and scalability considerations\n`;
            analysis += `- Testing strategy and quality assurance approach\n`;
            analysis += `- Timeline feasibility based on technical complexity\n\n`;
            
            analysis += `🛠️ TECHNICAL RECOMMENDATIONS:\n`;
            analysis += `- Which tasks need additional technical expertise or resources?\n`;
            analysis += `- What technical debt or architectural concerns do you identify?\n`;
            analysis += `- How can technical implementation be optimized for better efficiency?\n`;
            analysis += `- What technical standards or best practices should be applied?\n`;
            analysis += `- Which tasks have technical dependencies that could cause delays?\n`;
            analysis += `- What technical documentation or knowledge sharing is needed?\n`;
            analysis += `- How should technical reviews and code quality checks be structured?\n\n`;
            
            analysis += `Please provide detailed technical explanations that help understand the true status, complexity, and technical requirements of each task in a comprehensive yet accessible manner.\n`;
            
            return analysis;
        }

        function copyTaskStateAnalysis() {
            const analysisContent = document.getElementById('taskStateContent').textContent;
            if (analysisContent === 'Load historical data files and click "Analyze Tasks" to generate comprehensive task state analysis for GenAI...') {
                alert('Please generate an analysis first!');
                return;
            }

            navigator.clipboard.writeText(analysisContent).then(() => {
                alert('Task state analysis copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy. Please select and copy manually.');
            });
        }

        function exportTaskStateAnalysis() {
            const analysisContent = document.getElementById('taskStateContent').textContent;
            if (analysisContent === 'Load historical data files and click "Analyze Tasks" to generate comprehensive task state analysis for GenAI...') {
                alert('Please generate an analysis first!');
                return;
            }

            const dataBlob = new Blob([analysisContent], {type: 'text/plain'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `task-state-analysis-${new Date().toISOString().split('T')[0]}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportTaskStateCSV() {
            if (taskStateData.length === 0) {
                alert('Please load task state data first!');
                return;
            }

            let csvContent = 'Date,Member Name,Role,Task Title,Task Status,Task Issue,Task Notes,Days in Progress,Status Changes,Technical Context,Business Impact,Estimated Effort,Required Skills,Dependencies\n';
            
            const taskTimelines = buildTaskTimelines();
            
            Object.entries(taskTimelines).forEach(([memberName, memberTasks]) => {
                Object.entries(memberTasks).forEach(([taskTitle, timeline]) => {
                    const latestEntry = timeline[timeline.length - 1];
                    const firstEntry = timeline[0];
                    const daysSinceStart = Math.ceil((new Date(latestEntry.date) - new Date(firstEntry.date)) / (1000 * 60 * 60 * 24)) + 1;
                    const statusChanges = timeline.reduce((changes, entry, index) => 
                        index > 0 && entry.status !== timeline[index - 1].status ? changes + 1 : changes, 0);
                    
                    const memberData = taskStateData[taskStateData.length - 1].teamData.find(m => m.name === memberName);
                    const role = memberData ? memberData.role : 'Unknown';
                    
                    const understanding = latestEntry.understanding || {};
                    
                    csvContent += `"${latestEntry.date}","${memberName}","${role}","${taskTitle}","${latestEntry.status}","${(latestEntry.issue || '').replace(/"/g, '""')}","${(latestEntry.notes || '').replace(/"/g, '""')}",${daysSinceStart},${statusChanges},"${(understanding.technicalContext || '').replace(/"/g, '""')}","${(understanding.businessImpact || '').replace(/"/g, '""')}","${understanding.estimatedEffort || ''}","${(understanding.skillsRequired || []).join('; ')}","${(understanding.dependencies || []).join('; ')}"\n`;
                });
            });

            const dataBlob = new Blob([csvContent], {type: 'text/csv'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `task-state-data-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            URL.revokeObjectURL(url);
            
            alert(`Task state data exported as CSV`);
        }

        // AI Summary Compression Functions
        function compressAIContent(content) {
            if (!content || content.trim().length === 0) {
                return content;
            }
            
            let compressed = content
                // Remove excessive whitespace and empty lines
                .replace(/\n\s*\n\s*\n/g, '\n\n')  // Replace 3+ empty lines with 2
                .replace(/\n\s*\n\s*\n/g, '\n\n')  // Run again to catch remaining
                .replace(/[ \t]+/g, ' ')            // Replace multiple spaces/tabs with single space
                .replace(/\n /g, '\n')              // Remove leading spaces after newlines
                .replace(/ \n/g, '\n')              // Remove trailing spaces before newlines
                
                // Optimize section separators
                .replace(/={3,}/g, '===')           // Reduce excessive equal signs
                .replace(/-{3,}/g, '---')           // Reduce excessive dashes
                .replace(/_{3,}/g, '___')           // Reduce excessive underscores
                
                // Convert multi-line bullet points to single line (MAIN COMPRESSION FEATURE)
                .replace(/(\n\s*[-•]\s*[^\n]+)(\n\s*[-•]\s*[^\n]+)+/g, function(match) {
                    // Convert multiple bullet points into single line with " - " separators
                    return match
                        .replace(/\n\s*[-•]\s*/g, ' - ')  // Replace newlines + bullets with " - "
                        .replace(/^\s*[-•]\s*/, '- ');    // Clean up first bullet
                })
                
                // Convert multi-line numbered lists to single line
                .replace(/(\n\s*\d+\.\s*[^\n]+)(\n\s*\d+\.\s*[^\n]+)+/g, function(match) {
                    return match
                        .replace(/\n\s*\d+\.\s*/g, ' - ')  // Replace numbered items with " - "
                        .replace(/^\s*\d+\.\s*/, '- ');    // Clean up first item
                })
                
                // Compress repetitive patterns
                .replace(/\n\s*•\s*/g, '\n• ')      // Standardize remaining bullet points
                .replace(/\n\s*-\s*/g, '\n- ')      // Standardize remaining dashes
                
                // Remove redundant spacing around headers
                .replace(/\n\s*([A-Z][A-Z\s&:]+):\s*\n/g, '\n$1:\n')
                .replace(/\n\s*(🎯|📊|📋|🔧|💬|🚫|🔗|🛠️|📈|🤖|👤|✅|⚠️|🔥|⚡|📝)\s*/g, '\n$1 ')
                
                // Optimize common phrases
                .replace(/\n\s*Status:\s*/g, '\nStatus: ')
                .replace(/\n\s*Priority:\s*/g, '\nPriority: ')
                .replace(/\n\s*Progress:\s*/g, '\nProgress: ')
                .replace(/\n\s*Dependencies:\s*/g, '\nDeps: ')
                .replace(/\n\s*Requirements:\s*/g, '\nReqs: ')
                .replace(/estimated effort/gi, 'effort')
                .replace(/implementation/gi, 'impl')
                .replace(/development/gi, 'dev')
                .replace(/application/gi, 'app')
                .replace(/configuration/gi, 'config')
                .replace(/authentication/gi, 'auth')
                .replace(/authorization/gi, 'authz')
                
                // Final cleanup
                .trim();
            
            return compressed;
        }

        function compressTaskStateContent() {
            const contentElement = document.getElementById('taskStateContent');
            const currentContent = contentElement.textContent;
            
            if (!currentContent || currentContent === 'Load historical data files and click "Analyze Tasks" to generate comprehensive task state analysis for GenAI...') {
                alert('Please generate a summary first!');
                return;
            }
            
            const compressedContent = compressAIContent(currentContent);
            const originalLength = currentContent.length;
            const compressedLength = compressedContent.length;
            const compressionRatio = ((originalLength - compressedLength) / originalLength * 100).toFixed(1);
            
            contentElement.textContent = compressedContent;
            alert(`Summary compressed! Reduced from ${originalLength} to ${compressedLength} characters (${compressionRatio}% reduction)`);
        }

        function compressWeeklySummaryContent() {
            const contentElement = document.getElementById('weeklySummaryContent');
            const currentContent = contentElement.textContent;
            
            if (!currentContent || currentContent === 'Select week start date and load daily data files to generate weekly summary...') {
                alert('Please generate a weekly summary first!');
                return;
            }
            
            const compressedContent = compressAIContent(currentContent);
            const originalLength = currentContent.length;
            const compressedLength = compressedContent.length;
            const compressionRatio = ((originalLength - compressedLength) / originalLength * 100).toFixed(1);
            
            contentElement.textContent = compressedContent;
            alert(`Weekly summary compressed! Reduced from ${originalLength} to ${compressedLength} characters (${compressionRatio}% reduction)`);
        }
    </script>
</body>
</html>